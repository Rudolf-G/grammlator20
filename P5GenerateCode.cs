using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace Grammlator {
   internal partial class P5GenerateCode {
      public static void MakeInstanceAndExecute(P5CodegenCS Codegen)
         => new P5GenerateCode(Codegen).Execute();

      /// <summary>
      /// Generate code
      /// </summary>
      /// <param name="CodeGen"></param>
      private P5GenerateCode(P5CodegenCS CodeGen) => this.codegen = CodeGen;
      private readonly P5CodegenCS codegen;

      /* TODO Not yet implemented:
       *    only an idea: allow different sets of terminal symbols generated by different classes
       *       each with its own peek and accept instructions
       *       
       *    CHECK is there garbadge in the program from some older prefix attempts
       *    
       *    If states are reached only via look ahead actions actions (no accept)
       *      then they do not need a peek instruction;
       *      then only those terminal symbols can occur as input symbols,
       *      which are allowed symbols for those reduce actions.
       *      In some states this might avoid error actions!
       *    
       *    Error handling: for each state try to find at least 1 terminal symbol which will lead
       *    (via other states and the respective symbols) to halt
       *    
       *    Recognize states which will never lead to halt (recognize endless loop example).
       *    
       *    */

      private readonly Int32 indentationLevelLimit = GlobalVariables.IndentationLevelLimit;

      private void Execute()
      {
         // Determine whether the generated code will modify the attribute stack
         GlobalVariables.reductionsModifyAttributStack = false;
         foreach (ReduceAction reduction in GlobalVariables.ListOfAllReductions)
         {
            if (reduction.Calls > 0 && reduction.AttributeStackAdjustment != 0)
            {
               GlobalVariables.reductionsModifyAttributStack = true;
               break;
            }
         }

         codegen.GenerateStartOfCode(
             GenerateStateStackInitialCountVariable: GlobalVariables.CountOfStatesWithStateStackNumber > 0,
             GenerateAttributeStackInitialCountVariable:
               GlobalVariables.reductionsModifyAttributStack && GlobalVariables.TheOnlyOneErrorHaltAction.Calls > 0
             // The variable AttributeStackInitialCount is used by ErrorHaltActions, if the attributestack is used
             );

         // Prevent special actions from beeing generated somewhere inside the generated code.
         // They will be gnerated at the end of the generated code (see below).
         GlobalVariables.TheEndOfGeneratedCodeAction.Calls = -GlobalVariables.TheEndOfGeneratedCodeAction.Calls;
         GlobalVariables.TheOnlyOneErrorHaltAction.Calls = -GlobalVariables.TheOnlyOneErrorHaltAction.Calls;

         // Generate the code for the parsers first action and the sequence of actions reached from this action without goto
         GenerateCodeSequence(
             GlobalVariables.Startaction,
            accept: false,
            labelMustBeGenerated: false);

         // Generate all the actions which are reached by goto and which are not yet generated
         // 1. generate code for all actions which are called more than once and therefore need a label
         //    and for all actions which can be reached from those actions without goto
         GenerateCodeWithLabels(2);
         // 2. generate code for all other actions
         GenerateCodeWithLabels(1);

         // Allow the special actions (see above) to be gnerated and generate them
         GlobalVariables.TheOnlyOneErrorHaltAction.Calls = -GlobalVariables.TheOnlyOneErrorHaltAction.Calls;
         GlobalVariables.TheEndOfGeneratedCodeAction.Calls = -GlobalVariables.TheEndOfGeneratedCodeAction.Calls;
         if (GlobalVariables.TheOnlyOneErrorHaltAction.Calls > 0)
         {
            GenerateCodeSequence(GlobalVariables.TheOnlyOneErrorHaltAction, GlobalVariables.TheOnlyOneErrorHaltAction.AcceptCalls > 0,
               labelMustBeGenerated: true);
         }
         if (GlobalVariables.TheEndOfGeneratedCodeAction.Calls > 0)
         {
            GenerateCodeSequence(GlobalVariables.TheEndOfGeneratedCodeAction, GlobalVariables.TheEndOfGeneratedCodeAction.AcceptCalls > 0,
               labelMustBeGenerated: true);
         }

         codegen.GenerateEndOfRegion(); // and output code which may be buffered in codegen
      }

      private Boolean GeneratesGoto(Boolean generateAccept, ParserAction action, Int32 indentationLevel)
      {
         if (generateAccept)
         {
            if (action.AcceptCalls <= 0 // has already been generated
                || (action.AcceptCalls >= 2 && indentationLevel > 0) // labels can not be generated in code blocks
                )
            {
               return true;
            }
         }

         return action.Calls <= 0
             || (action.Calls >= 2 && indentationLevel > 0)
             || indentationLevel >= indentationLevelLimit;
      }

      /// <summary>
      /// If the referenced (accept) parser action can be generated at the actual place of code
      /// <para>then
      /// if forced by <paramref name="forceLabel"/> or if the (accept) parser action is referenced more than
      /// once a label is generated.
      /// If <paramref name="generateAccept"/> the accept instruction is generated and as just described a label.
      /// </para>
      /// Else a goto is generated and true is returned.
      /// </summary>
      /// <param name="forceLabel">Forces the generation of a label. The IndentationLevelLevel must be 0.</param>
      /// <param name="generateAccept">Selects whether the action will be generated with accept</param>
      /// <param name="parserAction">The action to which a goto or for which a label (if needed) shall be generated</param>
      /// <param name="beginOfBlockHasBeenGenerated">Gibt an, ob eine öffnende Klammer erzeugt wurde</param>
      /// 
      /// <returns>true, if goto has been generated</returns>
      private Boolean GenerateOptionalLabelOptionalAcceptOrGoto(
         Boolean forceLabel, // because goto has been generated on IndentationLevel==0
         Boolean generateAccept,
         ParserAction parserAction,
         ref Boolean beginOfBlockHasBeenGenerated)
      {
         bool InsideBlock = codegen.IndentationLevel > 0;

         if (generateAccept)
         {
            // generate accept part of action
            if (GenerateLabelOrGotoOrNothing
                  (forceLabel,
                   commentIfNoLabel: !(generateAccept || parserAction is ErrorhandlingAction || parserAction is ErrorHaltAction),
                   P5CodegenCS.GotoLabel(parserAction, accept: true),
                   parserAction.AcceptCalls,
                   InsideBlock))
               return true; // generated "goto accept..."

            // generated label "accept:..." or nothing;
            // now generate begin of cascaded block if inside of a new block
            if (InsideBlock && !beginOfBlockHasBeenGenerated)
            {
               codegen.GenerateBeginOfBlock();
               beginOfBlockHasBeenGenerated = true;
            }

            // generate accept instruction
            codegen.IndentExactly();
            codegen.GenerateAcceptInstruction();
            parserAction.AcceptCalls = 0; // mark that the accept part of the action has been generated
            forceLabel = false; // forceLabel has already been evaluated
         }

         //generate action part of action
         if (GenerateLabelOrGotoOrNothing
               (forceLabel,
                commentIfNoLabel:
                !(parserAction is ErrorhandlingAction
                  || parserAction is ErrorHaltAction
                  || parserAction is HaltAction),
                P5CodegenCS.GotoLabel(parserAction, accept: false),
                parserAction.Calls,
                insideBlock: codegen.IndentationLevel > 0))
            return true; // generated goto

         parserAction.Calls = 0;  // mark that the begin of the action part of the parser code has been generated
                                  // the parser code will be generated by the calling method immediately
         return false; // generated begin of the action part
      } // GenerateOptionalLabelOptionalAcceptOrGoto

      private Boolean GenerateLabelOrGotoOrNothing(
         bool forceLabel, // because goto has been generated on IndentationLevel==0
         bool commentIfNoLabel,
         string label, // codegen.GenerateLabel(parserAction, generateAccept)
         int calls, // = generateAccept ? parserAction.AcceptCalls : parserAction.Calls;
         bool insideBlock // IndentationLevel > 0
         )
      {
         Debug.Assert(!(forceLabel && insideBlock));

         bool GenerateGoto =
            calls <= 0 // code has been already generated or must not be generated
            || (calls > 1 && insideBlock)  // code with more than 1 reference needs label but label not allowed in block
            || codegen.IndentationLevel >= indentationLevelLimit; // code would be indented to much

         bool GenerateLabel =
            !GenerateGoto &&
            (forceLabel || calls > 1);

         if (GenerateGoto)
         {
            codegen.GenerateGoto(label);
            return true; // goto has been generated
         }

         if (GenerateLabel)
         {
            codegen.GenerateLabel(label);
         }
         else if (commentIfNoLabel)
            codegen.IndentExactly().Append("// ").Append(label).AppendLine(":");

         return false;

      } // GenerateLabelOrGotoOrNothing (...)

      public struct ActionAndCounter {
         public Int32 Counter;
         public Int32 MaxCondition, MinCondition;
         public ParserAction Action;

         public ActionAndCounter(Int32 counter, ParserAction action, int minMaxCondition)
         {
            this.Counter = counter;
            this.Action = action;
            this.MinCondition = minMaxCondition;
            this.MaxCondition = minMaxCondition;
         }
      }

      /// <summary>
      /// In der BranchToGenerate.ListOfCases kann als Folge der Optimierungen die gleiche Aktion mit verschiedenen Kennungen vorkommen.
      /// In der ActionCounterList kommt jede Aktion daraus genau einmal vor. Der Zähler gibt an, wie oft sie in der ListOfCases vorkommt.
      /// </summary>
      public class ActionCounterList : List<ActionAndCounter> {
         private ActionCounterList(Int32 capacity) : base(capacity) { }

         private ActionCounterList()
         {
         }

         /// <summary>
         /// Constructs an ActionCounterList with the same length as the ListOfCases of the BranchToGenerate,
         /// adds all different branchcases counting duplicates, finally trims the list
         /// </summary>
         /// <param name="BranchToGenerate"></param>
         public ActionCounterList(BranchAction BranchToGenerate) : this(BranchToGenerate.ListOfCases.Count)
         {
            foreach (BranchcaseStruct branchcase in BranchToGenerate.ListOfCases)
            {
               // Die Aktion in der Liste suchen:
               Int32 FoundIndex = FindIndex(x => x.Action == branchcase.BranchcaseAction);

               if (FoundIndex == -1)
               { // not found
                  Add(
                     new ActionAndCounter(counter: 1, action: branchcase.BranchcaseAction,
                     minMaxCondition: branchcase.BranchcaseCondition)
                     );
               }
               else
               { // found:  increment counter and update MaxCondition
                  ActionAndCounter actionAndCounter = this[FoundIndex];
                  actionAndCounter.Counter++;
                  if (actionAndCounter.MinCondition > branchcase.BranchcaseCondition)
                     actionAndCounter.MinCondition = branchcase.BranchcaseCondition;
                  if (actionAndCounter.MaxCondition < branchcase.BranchcaseCondition)
                     actionAndCounter.MaxCondition = branchcase.BranchcaseCondition;
                  this[FoundIndex] = actionAndCounter;
               }
            }
            TrimExcess();
         }
      }

      private ParserAction GenerateCondionalActionsOfBranch(BranchAction BranchToGenerate, out Boolean Accept)
      {
         // Create a CounterList which is ready to use preset with one entry and counter for each different action in BranchtoGenerate  
         var CounterList = new ActionCounterList(BranchToGenerate);

         // if there is only one action: return it to be generated without condition
         if (CounterList.Count == 1)
         {
            Accept = false;
            return CounterList[0].Action;
         }

         // Select a default action
         // There are different criteria to select the default action:
         //   select the most frequent action to reduce the conditions;
         //   avoid goto actions to move them into the conditional part;
         //   avoid other simple actions to put them in the conditional part

         Int32 MinIndex = 0, PriorityIndex = 0, MaxIndex = 0;

         Int32 MinCondition = int.MaxValue;
         Int32 MaxCondition = int.MinValue;

         Int32 MinPriority = int.MinValue;
         Int32 Priority = Int32.MinValue;

         for (int i = 0; i < CounterList.Count; i++)
         {
            var actionAndCounter = CounterList[i];
            // Select a default action to be generated as last:
            // select the most frequent action and if equal frequency
            // prefer actions with larger branch condition (to reduce the span of values to be tested in the generated switch)

            Int32 thisPriority = actionAndCounter.Counter * 1000 + actionAndCounter.MaxCondition;

            // but reduce the priority of actions which will be generated as goto
            if (GeneratesGoto(generateAccept: false, actionAndCounter.Action, codegen.IndentationLevel)
                // or of actions which will loop back 
                || (actionAndCounter.Action as ReduceAction)?.NextAction == BranchToGenerate
                // or of indirect or direct HaltActions
                || (actionAndCounter.Action as ReduceAction)?.NextAction is HaltAction
                || actionAndCounter.Action is HaltAction
                )
            {
               thisPriority -= (int.MaxValue >> 1);
            }

            if (actionAndCounter.MinCondition < MinCondition)
            {
               MinCondition = actionAndCounter.MinCondition;
               MinIndex = i;
               MinPriority = thisPriority;
            }
            if (actionAndCounter.MaxCondition > MaxCondition)
            {
               MaxCondition = actionAndCounter.MaxCondition;
               MaxIndex = i;
            }

            if (thisPriority > Priority)
            {
               PriorityIndex = i;
               Priority = thisPriority;
            }
         }

         // If the action with the MaxIndex didn't get priority 
         // then check if the action with the MinIndex is qualified as default action
         if (PriorityIndex != MaxIndex && MinPriority > 0)
            PriorityIndex = MinIndex;

         var defaultAction = CounterList[PriorityIndex].Action;

         // If there are only 2 different actions one of which has only one condition (Counter==1) to check for
         // then it is possible to generate an IF condition with one test for equality (or unequality)
         if (CounterList.Count == 2 && (CounterList[0].Counter == 1 || CounterList[1].Counter == 1))
         {
            GenerateBranchAsIFInstruction(BranchToGenerate, CounterList, defaultAction);
            Accept = false;
            return defaultAction;
         }

         return GenerateBranchAsSwitch(BranchToGenerate, out Accept, CounterList, defaultAction);
      }

      private ParserAction GenerateBranchAsSwitch(
          BranchAction branchToGenerate, out Boolean accept, ActionCounterList counterList, ParserAction defaultAction)
      {
         // Generate a switch statement
         // Für jede Aktion ungleich Defaultaktion in der Zählliste alle gleichen Aktionen in der Falliste der Verzweigung suchen
         // und eine oder mehrere Case-Anweisungen erzeugen sowie einmal die Codefolge für die Aktion

         codegen.IndentExactly()
            .Append("switch (")
            .Append(GlobalVariables.StateStack)
            .Append(".Peek())")
            .IndentExactly()
            .Append("{");

         foreach (ActionAndCounter ElementOFCounterList in counterList)
         {
            if (ElementOFCounterList.Action != defaultAction)
            {
               // Alle gleichen Aktionen suchen
               foreach (BranchcaseStruct f in branchToGenerate.ListOfCases)
               {
                  if (f.BranchcaseAction == ElementOFCounterList.Action)
                     codegen.IndentExactly()
                        .Append("case ")
                        .Append(f.BranchcaseCondition.ToString())
                        .Append(": ");

                  // codegen.AppendInstruction("case ", f.BranchcaseCondition.ToString(), ": ");
               }

               // Die zugehörige Codefolge erzeugen
               codegen.IncrementIndentationLevel();
               GenerateCodeSequence(ElementOFCounterList.Action, false, false);
               codegen.DecrementIndentationLevel();
               // Die Codefolge endet immer mit einem GOTO - auch bei Halt !
            }
         }

         // Für die Defaultaktion analog

         // Alle gleichen Aktionen suchen und die case-Anweisungen als Kommentar erzeugen
         // Falls mehrere Fälle zusammengefast werden, ist die Zahl der Aufrufe der default-Aktion entsprechend zu verringern
         codegen.Indent().Append("/*");
         Int32 countOfDefaultCases = 0;
         foreach (BranchcaseStruct f in branchToGenerate.ListOfCases)
         {
            if (f.BranchcaseAction == defaultAction)
            {
               countOfDefaultCases++;
               codegen.AppendWithOptionalLinebreak("case ", f.BranchcaseCondition.ToString(), ": ");
            }
         }

         if (countOfDefaultCases > 1)
            defaultAction.Calls -= countOfDefaultCases - 1;
         // Die auskommentierte Default-Codefolge  und das Kommentarende erzeugen
         codegen.IndentAndAppendLine("default: break; */")
         .IndentExactly()
         .AppendLine("}");
         accept = false;
         return defaultAction;
      }

      /// <summary>
      /// generate an if instruction so that not the default action will be executed conditionally 
      /// and the default action will remain to be generated in the codesequence
      /// </summary>
      /// <param name="branchToGenerate"></param>
      /// <param name="counterList"></param>
      /// <param name="defaultAction"></param>
      /// 
      private void GenerateBranchAsIFInstruction(BranchAction branchToGenerate, ActionCounterList counterList, ParserAction defaultAction)
      {
         // The simple condition case is the case whose BranchcaseCondition occurs only once in the branchToGenerate.ListOfCases
         // Its BranchcaseCondition (int value) will be used as condition in the generated if instruction.
         Int32 simpleConditionCaseIndex = 0, complexConditionCaseIndex = 1; // initial assignment

         if (counterList[simpleConditionCaseIndex].Counter != 1
            // if each of both action occurs only once use the default-Action as complexCase
            || (counterList[complexConditionCaseIndex].Counter == 1 && counterList[simpleConditionCaseIndex].Action == defaultAction))
         {
            // change the initial assignment
            simpleConditionCaseIndex = 1;
            complexConditionCaseIndex = 0;
         }

         ParserAction simpleConditionCase = counterList[simpleConditionCaseIndex].Action;
         ParserAction complexConditionCase = counterList[complexConditionCaseIndex].Action;
         Int32 complexCaseCounter = counterList[complexConditionCaseIndex].Counter;

         // simpleCaseCounter == 1   !

         // Find simpleCase in the ListOfCases - where it occurs only once - to get its condition
         Int32 simpleCaseCondition = branchToGenerate.ListOfCases.Find(x => x.BranchcaseAction == simpleConditionCase).BranchcaseCondition;

         if (complexConditionCase == defaultAction)
         {
            codegen.GenerateIfSPeek(false, simpleCaseCondition);
            // generate simpleCase
            codegen.IncrementIndentationLevel();
            GenerateCodeSequence(simpleConditionCase, false, false);
            codegen.DecrementIndentationLevel();
            // Adjust the number of calls because some actions are handled together 
            if (complexConditionCase.Calls > 0)
               complexConditionCase.Calls -= complexCaseCounter - 1;
         }
         else
         {  // simpleCase == defaultAction
            // generate the complement of the condition of simpleCase-condition 
            codegen.GenerateIfSPeek(true, simpleCaseCondition);
            // generate complexCase
            // Adjust the number of calls because some actions are handled together
            if (complexConditionCase.Calls > 0)
               complexConditionCase.Calls -= complexCaseCounter - 1;
            codegen.IncrementIndentationLevel();
            GenerateCodeSequence(complexConditionCase, false, false);
            codegen.DecrementIndentationLevel();
         }
      }

      /// <summary>
      /// Compare a1 and a2 such that sort will place
      /// the action with the lower complexity ahead of the other one.
      /// If both have the same complexity the action with the higher
      /// sum of weights of its symbols will be placed ahead of the other.
      /// The sum of weights of ErorHandlingActions is ignored.
      /// </summary>
      /// <param name="ActionA"></param>
      /// <param name="a2"></param>
      /// <returns></returns>
      private static Int32 CompareWeightandConditionComplexity(ParserAction a1, ParserAction a2)
      {
         // a1 < a2 => <0
         // a1 == a2 => 0
         // a1 > a2 => >0 
         if (!(a1 is ConditionalAction ActionA))
            return (a2 == null) ? 0 : 1;
         if (!(a2 is ConditionalAction ActionB))
            return -1;

         /* prefer symbols with highest weight, so that the user can influence 
          * the order of the generated if-tests (put the most frequent group of terminals symbols
          * at the beginning or the end of the list of terminals symbols)
          */

         /* Conflicting purposes:
          * - order actions by increasing complexity, because preceding checks may reduce complexity of actions
          * - order actions with decreasing sum of weights (probability) so that symbols
          *   which occur with higher probability are checked first
          * - give error actions lower priority
          * 
          * Actions with same complexity should be ordered by decreasing weight
          *  
          */

         Single PositionA = ActionA as ConditionalAction is ErrorhandlingAction
             ? (ActionA).Complexity * 100_000
             : (ActionA).Complexity * 100_000 - (ActionA).SumOfWeights;

         Single PositionB = ActionB is ErrorhandlingAction
             ? ActionB.Complexity * 100_000
             : (ActionB.Complexity * 100_000) - ActionB.SumOfWeights;

         if (PositionA != PositionB)
            return (Int32)(PositionA - PositionB);

         return (ActionA).IdNumber - ActionB.IdNumber;
      }

      /// <summary>
      /// Compares ActionA.TerminalSymbols.IndexOfFirstTrueElement() with ActionB...
      /// </summary>
      /// <param name="a">Action A</param>
      /// <param name="b">Action B</param>
      /// <returns></returns>
      private static Int32 CompareIndexOfFirstTrueElement(ParserAction a, ParserAction b)
      {
         if (!(a is ConditionalAction ActionA))
            return (b == null) ? 0 : 1;
         if (!(b is ConditionalAction ActionB))
            return -1;

         Int32 First1 = ActionA.TerminalSymbols.IndexOfFirstTrueElement();
         Int32 First2 = ActionB.TerminalSymbols.IndexOfFirstTrueElement();

         if (First1 != First2)
            return First1 - First2;

         return ActionA.IdNumber - ActionB.IdNumber;
      }

      /// <summary>
      /// Generates nothing if .Calls (resp. .AccepCalls) &lt;=0.
      /// Generates goto xxx, if the code has been generated or can not be generated at the actual nesting level.
      /// Generates accept if the action to be generated is a <see cref="TerminalTransition"/>.
      /// Sets .Calls (resp. .AcceptCalls) to 0.
      /// </summary>
      /// <param name="actionToGenerate"></param>
      /// <param name="labelMustBeGenerated"></param>
      /// 
      private void GenerateCodeSequence(ParserActionWithNextAction actionToGenerate, Boolean labelMustBeGenerated)
      {
         GenerateCodeSequence(
             actionToGenerate:
                actionToGenerate is ErrorhandlingAction || actionToGenerate is PrioritySelectAction
                   ? actionToGenerate // ErrorhandlingAction | PrioritySelectAction
                   : actionToGenerate.NextAction, // LookaheadAction | TerminalTransition: condition has been generated already
            accept: actionToGenerate is TerminalTransition,
            labelMustBeGenerated: labelMustBeGenerated);
      }

      readonly StringBuilder tempBuilder = new StringBuilder(4000);

      /// <summary>
      /// Generates nothing if .Calls (resp. .AccepCalls) &lt;=0.
      /// Generates goto xxx, if the code has been generated or can not be generated at the actual nesting leve.
      /// Sets .Calls (resp. .AcceptCalls) to 0.
      /// </summary>
      /// <param name="actionToGenerate"></param>
      /// <param name="accept"></param>
      /// <param name="labelMustBeGenerated"></param>
      /// 
      [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "e")]
      private void GenerateCodeSequence(ParserAction actionToGenerate, Boolean accept, Boolean labelMustBeGenerated)
      {
         ParserAction? ActionToGenerate = actionToGenerate;
         Boolean Accept = accept;
         Boolean GotoHasBeenGenerated = labelMustBeGenerated;

         Debug.Assert(tempBuilder.Length == 0, $"sbCodeSequence should be cleared at end of {nameof(GenerateCodeSequence)}");

         Boolean BeginOfBlockHasBeenGenerated = false;

         while (ActionToGenerate != null)
         {
            GotoHasBeenGenerated =
                GenerateOptionalLabelOptionalAcceptOrGoto(
                   forceLabel: GotoHasBeenGenerated,
                   generateAccept: Accept,
                   parserAction: ActionToGenerate,
                   beginOfBlockHasBeenGenerated: ref BeginOfBlockHasBeenGenerated);

            if (GotoHasBeenGenerated)
               break;

            // gegebenenfalls Blockanfang erzeugen
            if (!BeginOfBlockHasBeenGenerated && codegen.IndentationLevel > 0)
            {
               codegen.GenerateBeginOfBlock();
               BeginOfBlockHasBeenGenerated = true;
            }

            switch (ActionToGenerate) //TODO replace all cases by default "ActionToGenerate = actionToGenerate.Generate(codegen, out Accept);"
            {
            case ParserState state:
            {
               ActionToGenerate = GenerateState(out Accept, state, tempBuilder);
               break;
            }

            case BranchAction branch:
            {
               ActionToGenerate = GenerateBranch(out Accept, branch);
               break;
            }

            case PrioritySelectAction ps:
            {
               ActionToGenerate = ps.NextAction;
               break;
            }

            case PriorityBranchAction pb:
            {
               ActionToGenerate = GeneratePriorityBranch(out Accept, pb);
               break;
            }

            default:
            {
               ActionToGenerate = ActionToGenerate.Generate(codegen, out Accept);
               break;
               //throw new ErrorInGrammlatorProgramException
               //         ($"illegal or unknown type {ActionToGenerate} in {nameof(P5GenerateCode.GenerateCodeSequence)}");
            }
            } // switch
         } // while (ActionToGenerate != null)

         if (BeginOfBlockHasBeenGenerated)
         {
            codegen.IndentExactly();
            codegen.GenerateEndOfBlock("");
         }

         // No action to generate => if topmost level the next code can only be reached by a goto.
         // Generate an empty line preceding the label that will be generated.
         if (codegen.IndentationLevel == 0)
            codegen.AppendLine(' ');

         this.tempBuilder.Clear();
      } // private ... CodefolgeErzeugen(...)

      private ParserAction GenerateBranch(out Boolean Accept, BranchAction BranchactionToGenerate)
      {
         return GenerateCondionalActionsOfBranch(BranchactionToGenerate, out Accept);
      }

      private ParserAction GeneratePriorityBranch(out Boolean accept, PriorityBranchAction ps)
      {
         // TOCHECK The sequence of the actions is relevant if there are some with same priority: make it reproducible.
         // If there is a constant condition, this is always first. Only this may be a shift operation
         // which should have higher priority than LookAhead operations.
         codegen.IndentExactly();
         codegen.AppendLine("/* Dynamic priority controlled actions */");
         int PrioritiesCount = ps.DynamicPriorityActions.Count + ((ps.ConstantPriorityAction == null) ? 0 : 1);

         if( PrioritiesCount==2)
            return GeneratePriorityBranchAsIfThen(out accept, ps);

         return GeneratePriorityBranchAsSwitch(out accept, ps);
      }

      private ParserAction GeneratePriorityBranchAsIfThen(out Boolean accept, PriorityBranchAction ps)
      {
         codegen.Append(" if (");
         codegen.IncrementIndentationLevel();

         // First argument of comparision
         ParserActionWithNextAction IfDependentAction;
         if (ps.ConstantPriorityAction != null)
         {
            codegen.Append(ps.ConstantPriority);
            IfDependentAction = ps.ConstantPriorityAction;
         }
         else
         {
            codegen
              .AppendLine() // empty line preceding method call
              .GenerateSemanticMethodCall(ps.PriorityFunctions[0]);
            IfDependentAction = (ConditionalAction)ps.DynamicPriorityActions[0];
         }

         // ">=" and second argument of comparision and end of condition
         codegen.AppendLine()
            .DecrementIndentationLevel().IndentExactly().Append(">= ").IncrementIndentationLevel()
            .GenerateSemanticMethodCall(ps.PriorityFunctions[^1])
            .AppendLine().DecrementIndentationLevel().IndentExactly().AppendLine(")");

         // Conditional action
         codegen.IncrementIndentationLevel();
         GenerateCodeSequence
            (IfDependentAction.NextAction,
            accept: IfDependentAction is TerminalTransition ? true : false,
            labelMustBeGenerated: false);
         codegen.DecrementIndentationLevel();

         accept = ps.DynamicPriorityActions[^1] is TerminalTransition; // TOCHECK must be adapated if another action is the default
         return ((ConditionalAction)ps.DynamicPriorityActions[^1]).NextAction;
      }

      private ParserAction GeneratePriorityBranchAsSwitch(out Boolean accept, PriorityBranchAction ps)
      {

         codegen.AppendInstruction($"switch({GlobalVariables.MethodIndexOfMaximum}(");
         // TODO allow user to set MethodIndexOfMaximum

         // IndexOfMaximum has to return the index of the 1st occurence of the greatest argument. Then:
         // TerminalTransition (priority 0) has priority over dynamic priority value 0 because it is generated 1st !! 
         if (ps.ConstantPriorityAction != null)
            codegen.Append(ps.ConstantPriority).Append(", ");

         codegen.IncrementIndentationLevel();

         for (Int32 i = 0; i < ps.DynamicPriorityActions.Count; i++)
         {
            codegen.IndentExactly()
               .AppendLine() // empty line preceding method call
               .GenerateSemanticMethodCall(ps.PriorityFunctions[i]);
            if (i < ps.DynamicPriorityActions.Count - 1)
               codegen.Append(",");
            codegen.AppendLine(); // end of line

            if (i == ps.DynamicPriorityActions.Count - 1)
               codegen.AppendLine(); // empty line following method call
         }
         codegen.Indent().Append("))");

         codegen.DecrementIndentationLevel();
         codegen.IndentExactly().Append("{");
         // end of generating switch condition


         // generate switch cases
         Int32 CaseCount = 0;
         if (ps.ConstantPriorityAction != null)
         {
            ConditionalAction ca = (ConditionalAction)(ps.ConstantPriorityAction);

            codegen.IndentExactly().Append("case ").Append(CaseCount++).Append(": ");
            codegen.IncrementIndentationLevel();
            GenerateCodeSequence(
               ca.NextAction, // ca may be TerminalTransition or LookaheadAction: condition is included in condition of PrioritySelect 
               accept: ca is TerminalTransition,
               labelMustBeGenerated: false);
            codegen.DecrementIndentationLevel();
         }
         // do not generate a case for the last dynamic priority: this
         // is returned to be generated after the switch instruction (default)
         for (Int32 i = 0; i < ps.DynamicPriorityActions.Count - 1; i++)
         {
            codegen.IndentExactly().Append("case ").Append(CaseCount++).Append(": ");
            ConditionalAction ca = (ConditionalAction)ps.DynamicPriorityActions[i];
            codegen.IncrementIndentationLevel();
            GenerateCodeSequence
               (ca.NextAction,
               accept: false,  // dynamic priority actions always look ahead: can not be accepting actions
               labelMustBeGenerated: false);
            codegen.DecrementIndentationLevel();
         }
         codegen.IndentExactly().Append("}");

         accept = ps.DynamicPriorityActions[^1] is TerminalTransition;
         return ((ConditionalAction)ps.DynamicPriorityActions[^1]).NextAction;
      }

      /// <summary>
      /// generates all actions of the state including nested actions of some other states
      /// </summary>
      /// <param name="Accept"></param>
      /// <param name="State"></param>
      /// <param name="sbTemp"></param>
      /// 
      /// <returns>action which has to be generated as next action</returns>
      private ParserAction? GenerateState(out Boolean Accept, ParserState State, StringBuilder sbTemp)
      {
         // Generate description
         State.CoreItems.AppendToSB(sbTemp);

         if (State.ContainsErrorHandlerCall && !string.IsNullOrEmpty(GlobalVariables.VariableNameStateDescription))
         {
            // Generate assignment to VariableNameStateDescription (if defined)
            codegen.Indent();
            codegen.Append("const String ");
            codegen.Append(GlobalVariables.VariableNameStateDescription);
            codegen.Append(State.IdNumber + 1);
            codegen.Append(" =");
            codegen.AppendLine();

            // Generate the item descriptions to be assigned to the variable
            sbTemp.Replace("\\", "\\\\").Replace("\"", "\\\""); // escape the symbols which are not allowed in strings

            codegen.IndentAndAppendLinesWithSeparator(
                linesToAppend: sbTemp.ToString() // the strings describing the items of the state
                , stringPrecedingFirstLine: "     \""  // indentation and character """" in front of each string
                , separatorAtEndofLine: GlobalVariables.NewLineWithEscapes + "\""  // at end of each string except the last
                , separatorAtNewLine: "   + \"" // before each string except the first
                , stringAtEndOfLastLine: "\";" // after the last string
                );
            sbTemp.Clear();
            codegen.AppendLine();
         }
         else
         {
            sbTemp.Replace("*/", "* /"); // escape the symbols which are not allowed in comment

            codegen.IndentExactly().Append("/*");

            codegen.IndentAndAppendLinesWithSeparator(
                linesToAppend: sbTemp.ToString() // the strings describing the items of the state
                , stringPrecedingFirstLine: " "  // indentation and character """" in front of each string
                , separatorAtEndofLine: ""  // at end of each string except the last
                , separatorAtNewLine: " * " // before each string except the first
                , stringAtEndOfLastLine: "" // after the last string
                );
            codegen.Append(" */");
            sbTemp.Clear();
         }

         codegen.Indent();

         // generate push to the state stack if necessary, generate comment im moved to actions
         if (State.StateStackNumber >= 0)
            codegen.GenerateStateStackPushWithOptionalLinebreak(State.StateStackNumber);
         else if (State.StateStackNumber <= -2)
            codegen.AppendLine("// *Push(" + (-State.StateStackNumber - 2).ToString() + ')');


         // The call of "FetchSymbol();" must be generated only if the state contains actions, which check the input symbol.
         // This is prepared  by shortening chains in phase 4 und implemented by the following.
         // TOCHECK 05 (low priority) Not yet implemented: "FetchSymbol();" needs not to be generated if all pathes leading to the state
         //   contain a "FetchSymbol();" and then not a "Accept(...)"

         if (State.Actions.Count == 1 && !(State.Actions[0] is TerminalTransition))
         {
            // generate unconditional action
         }
         else if (State.Actions.Count >= 1)
         {
            // If the state contains more than one action or one action, which is a terminal transition (all symbols allowed),
            // "PeekSymbol()" must be generated
            Debug.Assert(State.Actions.Count > 1
                || State.Actions[0] is LookaheadAction
                || State.Actions[0] is TerminalTransition
                || State.Actions[0] is ErrorhandlingAction
                );

            codegen.IndentExactly();

            codegen.AppendWithOptionalLinebreak(GlobalVariables.InstructionAssignSymbol);
         }
         else // State.Actions.Count = 0
         {
            // This shouldn't happen 'cause each state should at least contain one action (may be error action) 

            // TOCHECK 05 (low priority) ist die Behandlung von Zuständen ohne terminale Aktion so ok?
            // Sind Zustände, die keine erlaubte Aktion enthalten (resultierend aus z.B *=A; A=B; B=A;), entsprechend berücksichtigt
            GlobalVariables.OutputMessage(
                MessageTypeOrDestinationEnum.Error, "Check your grammar: no actions in state " + (State.IdNumber + 1).ToString());

            ParserAction NextActionToGenerate = new ErrorhandlingAction(
                GlobalVariables.AllTerminalSymbols,
                idNumber: State.IdNumber,
                State);
            //NextActionToGenerate.Calls++;
            //GlobalVariables.TheOnlyOneErrorHaltAction.Calls++;
            Accept = false;
            return NextActionToGenerate;
         }

         return SortAndGenerateConditionalActionsOfState(State, out Accept); // => next action to generate or null
      }

      /// <summary>
      /// Sort actions depending on the weight of the terminals symbols and an estimation of the complexity
      /// of the if conditions to be generated and then generate "if (...){...}" code
      /// </summary>
      /// <param name="state">the state whose conditional actions are to be generated</param>
      /// <param name="accept">if the result is not null but an action then accept indicates that a call of accept has to be generated before the action will be generated</param>
      /// 
      /// <returns>Null or an unconditional action which has to be generated next</returns>
      /// <exception cref="ErrorInGrammlatorProgramException"></exception>
      private ParserAction? SortAndGenerateConditionalActionsOfState(ParserState state, out Boolean accept)
      {
         // vorher : Aktion zeigt auf Zustand
         // nachher: result == Folgeaktion == null oder 
         //          result == Folgeaktion und akzeptieren geben die Folgeaktion an    

         /* only one action in state => return it 
            only few actions         => generate if instructions
            else                     => generate switch instruction
         */

         // Test the state if it contains an unconditional action
         ParserAction? unconditionalAction = FindUnconditionalAction(state, out Int32 NumberOfConditionalActions);
         if (unconditionalAction != null && NumberOfConditionalActions <= 0)
         {
            accept = false;
            return unconditionalAction;
         }

         Debug.Assert(
            NumberOfConditionalActions == state.Actions.Count,
            "Error in phase 5: unconditional and other actions must not occur together in the same state"
            );

         if (state.IfComplexity > GlobalVariables.IfToSwitchBorder)
            return GenerateSwitchWithActionsOfState(state, out accept);

         // Sort the actions by increasing complexity of the condition.
         // Generated if cases can be ignored when generating conditions and the following more complex cases may be simplified.
         // Another sort criterion is to check the most probable input first (the input with highest weight).

         if (GlobalVariables.NumberOfTerminalSymbols > 0)
            state.Actions.Sort(CompareWeightandConditionComplexity);

         // Eine Fehleraktion am Ende möglichst mit der vorletzten Aktion tauschen,
         // da eine Fehleraktion immer die Sequenz unterbricht
         if (state.Actions.Count > 1 && state.Actions[^1] is ErrorhandlingAction)
         {
            ParserAction temp = state.Actions[^2];
            state.Actions[^2] = state.Actions[^1];
            state.Actions[^1] = temp;
         }

         // Test the state if it contains an unconditional action
         // und eine geeignete Folgeaktion heraussuchen, die als letzte Aktion unbedingt
         // erzeugt werden kann (möglichst keine Fehleraktion) - prüfen und die Intention  genau dokumentieren !!!!!
         // TODO diese Optimierung überarbeiten !!! keine Aktionen, die eine Marke erzeugen als Folgeaktion bevorzugen !!! 

         return GenerateConditionalActionsOfState(state, out accept);
      }

      private static void Swap<T>(ref T a, ref T b)
      {
         T temp = a;
         a = b;
         b = temp;
      }

      /// <summary>
      /// Sort actions depending on the terminal symbols
      /// then generate "switch(...)case ...:" code
      /// </summary>
      /// <param name="state"></param>
      /// <param name="accept"></param>
      /// 
      /// <returns>Unconditional action which has to be generated</returns>
      /// <exception cref="ErrorInGrammlatorProgramException"></exception>
      private ParserAction GenerateSwitchWithActionsOfState(ParserState state, out Boolean accept)
      {
         // Sort the actions by their first symbol to improve readability of the generated code
         if (GlobalVariables.NumberOfTerminalSymbols > 0)
            state.Actions.Sort(CompareIndexOfFirstTrueElement);

         codegen.IndentExactly();
         codegen.AppendWithOptionalLinebreak("switch (");
         codegen.Append(GlobalVariables.VariableNameSymbol);
         codegen.Append(")");
         codegen.GenerateBeginOfBlock();

         Int32 LeadingCount = 0, TrailingCount = 0, TerminalsCount = 0;
         ConditionalAction? LeadingAction = null, TrailingAction = null;

         for (int i = 0; i < state.Actions.Count; i++)
         {
            var ThisAction = (ConditionalAction)state.Actions[i];
            BitArray Terminals = ThisAction.TerminalSymbols;
            TerminalsCount = Terminals.Count;
            Int32 TerminalIndex = Terminals.FindNextTrue(-1); // not (LeadingCount - 1) because we want to find bugs
            Boolean IsDefaultAction = false;

            // Special case if Terminals contains the first terminal
            if (TerminalIndex == 0)
            {
               // remember this action and the count of leading terminals
               Debug.Assert(LeadingCount == 0, "Phase5: LeadingCount already != 0");
               LeadingAction = ThisAction;
               LeadingCount = Terminals.FindNextFalse(0);
               TerminalIndex = Terminals.FindNextTrue(LeadingCount);
               IsDefaultAction = true;

               // generate first part of comment
               codegen.IndentExactly();
               codegen.Append("// <= ");
               codegen.AppendWithPrefix(
                   GlobalVariables.TerminalSymbolEnum,
                   GlobalVariables.TerminalSymbolByIndex[LeadingCount - 1].Identifier
                   );
            }

            // Special case if Terminals contains the last terminal
            if (Terminals[TerminalsCount - 1])
            {
               // remember this action and the count of trailing terminals
               Debug.Assert(TrailingCount == 0, "Phase5: TrailingCount already != 0");
               TrailingAction = ThisAction;
               TrailingCount = TerminalsCount - Terminals.FindPrecedingFalse(Terminals.Count) - 1;
               IsDefaultAction = true;

               // generate first part of comment
               codegen.IndentExactly();
               codegen.Append("// >= ");
               codegen.AppendWithPrefix(
                   GlobalVariables.TerminalSymbolEnum,
                   GlobalVariables.TerminalSymbolByIndex[TerminalsCount - TrailingCount].Identifier
                   );
            }

            if (IsDefaultAction)
            {
               // generate second part of comment
               codegen.Append(": ");
               codegen.Append("goto ");
               codegen.Append(P5CodegenCS.GotoLabel(ThisAction));
               codegen.Append(" // see end of switch");
            }

            // if remaining terminal symbols, for each 
            bool RemainingSymbols = false;
            while (TerminalIndex < TerminalsCount - TrailingCount)
            {
               RemainingSymbols = true;
               // generate "case TerminalSymbol: " 
               codegen.IndentExactly();
               codegen.Append("case ");
               codegen.AppendWithPrefix(
                   GlobalVariables.TerminalSymbolEnum,
                   GlobalVariables.TerminalSymbolByIndex[TerminalIndex].Identifier
                   );
               codegen.Append(":");

               TerminalIndex = Terminals.FindNextTrue(TerminalIndex);
            }

            if (RemainingSymbols)
            {
               codegen.IncrementIndentationLevel();

               if (IsDefaultAction)
               {
                  // adjust the statistics because here a "goto label" will be generated
                  // in addition to the code generated in the default action.
                  // If the statistics are not adjusted those code may be generated without label.
                  if (ThisAction is TerminalTransition)
                     ThisAction.NextAction.AcceptCalls++;  // TOCHECK may .AcceptCalls++ whilst generating code be a bug (action may have been generated without label?)
                  else
                     ((ThisAction is ErrorhandlingAction && GlobalVariables.ErrorHandlerIsDefined) ? ThisAction : ThisAction.NextAction).Calls++;
                  // generate goto
                  codegen.GenerateGoto(
                     action: ThisAction is ErrorhandlingAction ? ThisAction : ThisAction.NextAction,
                     accept: ThisAction is TerminalTransition);
               }
               else
               {
                  GenerateCodeSequence(ThisAction, labelMustBeGenerated: false);
               }

               codegen.DecrementIndentationLevel();
            }
         }

         Debug.Assert(LeadingAction != null && TrailingAction != null, "Leading or Trailing Action is null");

         // generate end of switch statement
         codegen.GenerateEndOfBlock("end of switch");

         // implement "default:" as fall through

         ConditionalAction Action1 = LeadingAction, Action2 = TrailingAction;
         ParserAction Action1Generate = (Action1 is ErrorhandlingAction && GlobalVariables.ErrorHandlerIsDefined) ? Action1 : Action1.NextAction;
         ParserAction Action2Generate = (Action2 is ErrorhandlingAction && GlobalVariables.ErrorHandlerIsDefined) ? Action2 : Action2.NextAction;

         Boolean ActionsSwapped = false;

         // If there are two different default actions
         if (Action1Generate != Action2Generate)
         {
            // yes: generate if
            codegen.IndentExactly();
            codegen.Append("if (");
            codegen.Append(GlobalVariables.VariableNameSymbol);

            // prefer action which generates goto as first action
            // TODO else prefer action which does not generate a label
            if (GeneratesGoto(generateAccept: Action2 is TerminalTransition, Action2Generate, codegen.IndentationLevel) &&
                !GeneratesGoto(generateAccept: Action1 is TerminalTransition, Action1Generate, codegen.IndentationLevel))
            {
               Swap(ref Action1, ref Action2);
               Swap(ref Action1Generate, ref Action2Generate);
               ActionsSwapped = true;

               codegen.Append(" >= ")
               .AppendWithPrefix(
                   GlobalVariables.TerminalSymbolEnum,
                   GlobalVariables.TerminalSymbolByIndex[TerminalsCount - TrailingCount].Identifier
                   );
            }
            else
            {
               codegen.Append(" <= ");
               codegen.AppendWithPrefix(
                   GlobalVariables.TerminalSymbolEnum,
                   GlobalVariables.TerminalSymbolByIndex[LeadingCount - 1].Identifier
                   );
            }

            codegen.Append(") ");

            codegen.IncrementIndentationLevel();
            GenerateCodeSequence(Action1, labelMustBeGenerated: false);
            codegen.DecrementIndentationLevel();
         }

         // generate comment as Debug.Assert
         codegen.IndentExactly();
         codegen.Append("Debug.Assert(");
         if (Action1Generate == Action2Generate)
         {
            codegen.Append(GlobalVariables.VariableNameSymbol);
            codegen.Append(" <= ");
            codegen.AppendWithPrefix(
                GlobalVariables.TerminalSymbolEnum,
                GlobalVariables.TerminalSymbolByIndex[LeadingCount - 1].Identifier
                );
            codegen.Append(" || ");
            codegen.Append(GlobalVariables.VariableNameSymbol);
            codegen.Append(" >= ");
            codegen.AppendWithPrefix(
                GlobalVariables.TerminalSymbolEnum,
                GlobalVariables.TerminalSymbolByIndex[TerminalsCount - TrailingCount].Identifier
                );
         }
         else if (ActionsSwapped)
         {
            codegen.Append(GlobalVariables.VariableNameSymbol);
            codegen.Append(" <= ");
            codegen.AppendWithPrefix(
                GlobalVariables.TerminalSymbolEnum,
                GlobalVariables.TerminalSymbolByIndex[LeadingCount - 1].Identifier
                );
         }
         else
         {
            codegen.Append(GlobalVariables.VariableNameSymbol);
            codegen.Append(" >= ");
            codegen.AppendWithPrefix(
                GlobalVariables.TerminalSymbolEnum,
                GlobalVariables.TerminalSymbolByIndex[TerminalsCount - TrailingCount].Identifier
                );
         }
         codegen.AppendLine(");");
         codegen.AppendLine("");

         // generate Action2
         accept = Action2 is TerminalTransition; // TOCHECK try to avoid the out parameter "accept"?
         return Action2Generate; // TOCHECK: try to avoid the special handling of ErrorhandlingAction?
      }

      /// <summary>
      /// The state contains no unconditional action.
      /// Generate the conditional actions of the state and return an action (if any) to generate next.
      /// </summary>
      /// <param name="State"></param>
      /// <param name="Accept"></param>
      /// 
      /// <returns>next <see cref="ParserAction"/> to generate</returns>
      private ParserAction? GenerateConditionalActionsOfState(
          ParserState State,
         out Boolean Accept)
      {
         // all terminal symbols which are condition of one action can be ignored
         // in the conditions of all following actions (are not relevant)
         var relevantSymbols = new BitArray(GlobalVariables.AllTerminalSymbols);

         for (int i = 0; i < State.Actions.Count - 1; i++)
         {
            var a = (ConditionalAction)State.Actions[i];
            GenerateOneConditionalAction(a, relevantSymbols); // Modifies relevantSymbols
         }

         var LastAction = (ConditionalAction)State.Actions[^1];

         ParserAction? nextAction = LastAction; //CHECK may nextAction be null?
         if (LastAction is TerminalTransition || LastAction is LookaheadAction)
            nextAction = LastAction.NextAction; // TOCHECK must nextAction.Calls be reduced by 1 ??

         BitArray suppressedCondition = LastAction.TerminalSymbols;
         if (nextAction != null && suppressedCondition != null
            && !suppressedCondition.All())
         {
            GenerateConditionAsComment(suppressedCondition);
         }

         Accept = LastAction is TerminalTransition;
         return nextAction;
      }

      /// <summary>
      /// Test the state if it contains an unconditional action and return it (else null) and the number of conditional actions.
      /// </summary>
      /// <param name="state">The state which actions are to be tested</param>
      /// <param name="NumberOfConditionalActions">The number of conditional actions of the state</param>
      /// <returns>The last unconditional action of the state or null</returns>
      private static ParserAction? FindUnconditionalAction(ParserState state, out Int32 NumberOfConditionalActions)
      {
         NumberOfConditionalActions = 0;

         // If there is only one action which is a lookahead action (this may be the result of optimization)
         // look ahead must not be generated. The next action has to be generated without condition.
         if (state.Actions.Count == 1 && state.Actions[0] is LookaheadAction la)
            return la.NextAction;

         ParserAction? unconditionalAction = null;
         foreach (ParserAction a in state.Actions)
         {
            switch (a)
            {
            case ParserState _:
            case ReduceAction _:
            case HaltAction _:
            case BranchAction _:
            {
               if (unconditionalAction != null)
               {
                  throw new ErrorInGrammlatorProgramException
                     ($"There must not be a second unconditional action in state {state}");
               }

               unconditionalAction = a;
               break;
            }

            case TerminalTransition _:
            {
               NumberOfConditionalActions++;
               // even if all terminal symbols are allowed a terminal transition can not be skipped because 
               // accept has to be generated
               break;
            }

            case ErrorhandlingAction _:  // TOCHECK possible optimization has been performed
            case LookaheadAction _:
            case PrioritySelectAction _:
            {
               NumberOfConditionalActions++;
               break;
            }

            case Definition _:
            case DeletedParserAction _:
            case NonterminalTransition _:
            default:
               throw new ErrorInGrammlatorProgramException($"Error: a parser action of type {a} must not occur in P5");
            }
         }

         return unconditionalAction;
      }

      /// <summary>
      /// Erzeugt Codefolgen für Aktionen mit der geforderten Mindestaufrufanzahl
      /// </summary>
      /// <param name="MinimumOfCalls">Mindestzahl von Aufrufen</param>
      private void GenerateCodeWithLabels(Int32 MinimumOfCalls)
      {
         /* Each action a with a.xxxCalls == 1 has a good chance to be generated as part of another action
          * (if not prohibited by the nesting level limit). The generation of these actions is delayed.
          * 
          * Each action a with a.xxxCalls > 1 needs a label and can not be generated
          * in nested instructions (but following another action as next action).
          * 
          * The following code is a simple heuristic (!) to get a sequence where 
          * actions are generated earlier than actions they contain.
          * 
          * Another perhaps better to optimize solution would be to sort the actions in advance.
          */

         /* Generate ReduceActions early if
          * * their next action has not yet been generated
          * * their next action has more than one call
          * Typically the next action of ReduceActions are States.
          */

         foreach (ReduceAction r in GlobalVariables.ListOfAllReductions)
         {
            if (r.NextAction.Calls > 1)
            {
               if (r.AcceptCalls >= MinimumOfCalls)
                  GenerateCodeSequence(r, accept: true, labelMustBeGenerated: true);
               if (r.Calls >= MinimumOfCalls)
                  GenerateCodeSequence(r, accept: false, labelMustBeGenerated: true);
            }
         }

         /* Generate ParserStates early because they often include other actions or have a next action 
          */
         foreach (ParserState state in GlobalVariables.ListOfAllStates)
         {
            if (state.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(state, accept: true, labelMustBeGenerated: true);
            if (state.Calls >= MinimumOfCalls)
               GenerateCodeSequence(state, accept: false, labelMustBeGenerated: true);
         }

         /* Typically PrioritySelectActions will have PriorityBranchActions as NextAction
          * and PriorityBranchActions will have ReduceActions as NextActions
          */
         foreach (PrioritySelectAction ps in GlobalVariables.ListOfAllPrioritySelectActions)
         {
            if (ps.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(ps, accept: true, labelMustBeGenerated: true);
            if (ps.Calls >= MinimumOfCalls)
               GenerateCodeSequence(ps, accept: false, labelMustBeGenerated: true);
         }

         foreach (PriorityBranchAction pb in GlobalVariables.ListOfAllPriorityBranchActions)
         {
            if (pb.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(pb, accept: true, labelMustBeGenerated: true);
            if (pb.Calls >= MinimumOfCalls)
               GenerateCodeSequence(pb, accept: false, labelMustBeGenerated: true);
         }


         /* Generate the other ReduceActions 
          */
         foreach (ReduceAction r in GlobalVariables.ListOfAllReductions)
         {
            if (r.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(r, accept: true, labelMustBeGenerated: true);
            if (r.Calls >= MinimumOfCalls)
               GenerateCodeSequence(r, accept: false, labelMustBeGenerated: true);
         }

         /* Typically branches are next actions of ReduceActions. So generate them after those 
          */
         foreach (BranchAction b in GlobalVariables.ListOfAllBranchActions)
         {
            if (b.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(b, accept: true, labelMustBeGenerated: true);
            if (b.Calls >= MinimumOfCalls)
               GenerateCodeSequence(b, accept: false, labelMustBeGenerated: true);
         }

         foreach (ErrorhandlingAction e in GlobalVariables.ListOfAllErrorhandlingActions)
         {
            if (e.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(e, accept: true, labelMustBeGenerated: true);
            if (e.Calls >= MinimumOfCalls)
               GenerateCodeSequence(e, accept: false, labelMustBeGenerated: true);
         }

         foreach (HaltAction h in GlobalVariables.ListOfAllHaltActions)
         {
            if (h.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(h, accept: true, labelMustBeGenerated: true);
            if (h.Calls >= MinimumOfCalls)
               GenerateCodeSequence(h, accept: false, labelMustBeGenerated: true);
         }

         // PushStateActions are next actions of conditional actions.
         foreach (PushStateAction p in GlobalVariables.ListOfAllPushStateActions)
         {
            // Because AcceptCalls<=1, Calls==1 PushStateActions are generated without labels
            // and the following should only be executed
            // if this assumption is changed by some  modifications of grammlator 
            Debug.Assert(p.AcceptCalls <= 0 && p.Calls <= 0);
            if (p.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(p, accept: true, labelMustBeGenerated: true);
            if (p.Calls >= MinimumOfCalls)
               GenerateCodeSequence(p, accept: false, labelMustBeGenerated: true);
         }
      } // void FehlendenCodeErzeugen
   } // class Phase5
} // namespace ...




