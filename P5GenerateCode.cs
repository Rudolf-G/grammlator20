using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace grammlator {
   internal partial class P5GenerateCode {
      public static void MakeInstanceAndExecute(P5CodegenCS Codegen)
         => new P5GenerateCode(Codegen).Execute();

      /// <summary>
      /// Generate code
      /// </summary>
      /// <param name="codeGen"></param>
      private P5GenerateCode(P5CodegenCS codeGen)
      {
         this.Codegen = codeGen;
      }

      private readonly P5CodegenCS Codegen;

      /* TODO Not yet implemented:
       *    only an idea: allow different sets of terminal symbols generated by different classes
       *       each with its own peek and accept instructions
       *       
       *    CHECK is there garbadge in the program from some older prefix attempts
       *    
       *    If states are reached only via look ahead actions actions (no accept)
       *      then they do not need a peek instruction;
       *      then only those terminal symbols can occur as input symbols,
       *      which are allowed symbols for those reduce actions.
       *      In some states this might avoid error actions!
       *    
       *    Error handling: for each state try to find at least 1 terminal symbol which will lead
       *    (via other states and the respective symbols) to halt
       *    
       *    Recognize states which will never lead to halt (recognize endless loop example).
       *    
       *    */

      private void Execute()
      {
         // Determine whether the generated code will modify the attribute stack
         GlobalVariables.reductionsModifyAttributStack = false;
         foreach (ReduceAction reduction in GlobalVariables.ListOfAllReductions)
         {
            if (reduction.Calls > 0 && reduction.AttributeStackAdjustment != 0)
            {
               GlobalVariables.reductionsModifyAttributStack = true;
               break;
            }
         }

         // Check if the AttributeStack has to be reset here, because all xxx.Calls will be reset to 0
         Boolean CodeContainsErrorHalt = GlobalVariables.TheOnlyOneErrorHaltAction.Calls > 0;

         // Prevent special actions from beeing generated somewhere inside the generated code.
         // They will be gnerated at the end of the generated code (see below).
         GlobalVariables.TheEndOfGeneratedCodeAction.Calls = -GlobalVariables.TheEndOfGeneratedCodeAction.Calls;
         GlobalVariables.TheOnlyOneErrorHaltAction.Calls = -GlobalVariables.TheOnlyOneErrorHaltAction.Calls;

         // Generate the code for the parsers first action and the sequence of actions reached from this action without goto
         GenerateCodeSequence(Codegen,
             GlobalVariables.Startaction,
            accept: false,
            labelMustBeGenerated: false);

         // Generate all the actions which are reached by goto and which are not yet generated
         // 1. generate code for all actions which are called more than once and therefore need a label
         //    and for all actions which can be reached from those actions without goto
         GenerateCodeWithLabels(2);
         // 2. generate code for all other actions
         GenerateCodeWithLabels(1);

         // Allow the special actions (see above) to be gnerated and generate them
         GlobalVariables.TheOnlyOneErrorHaltAction.Calls = -GlobalVariables.TheOnlyOneErrorHaltAction.Calls;
         GlobalVariables.TheEndOfGeneratedCodeAction.Calls = -GlobalVariables.TheEndOfGeneratedCodeAction.Calls;
         if (GlobalVariables.TheOnlyOneErrorHaltAction.Calls > 0)
         {
            GenerateCodeSequence(Codegen,
               GlobalVariables.TheOnlyOneErrorHaltAction, GlobalVariables.TheOnlyOneErrorHaltAction.AcceptCalls > 0,
               labelMustBeGenerated: true);
         }
         if (GlobalVariables.TheEndOfGeneratedCodeAction.Calls > 0)
         {
            GenerateCodeSequence(Codegen,
               GlobalVariables.TheEndOfGeneratedCodeAction, GlobalVariables.TheEndOfGeneratedCodeAction.AcceptCalls > 0,
               labelMustBeGenerated: true);
         }

         Codegen.GenerateEndOfRegion(); // and output code which may be buffered in codegen

         // Now the declarations can be generated preceding the already generated instructions
         Codegen.GenerateStartOfCodeAndCopyCodeToResultBuilder(
            GenerateStateStackInitialCountVariable: GlobalVariables.CountOfStatesWithStateStackNumber > 0,
            GenerateAttributeStackInitialCountVariable:
            GlobalVariables.reductionsModifyAttributStack && CodeContainsErrorHalt
            // The variable AttributeStackInitialCount is used by ErrorHaltActions, if the attributestack is used
            );

         return;
      }

      internal static Boolean GeneratesGoto(Boolean generateAccept, ParserAction action, Int32 indentationLevel)
      {
         if (generateAccept)
         {
            if (action.AcceptCalls <= 0 // has already been generated
                || (action.AcceptCalls >= 2 && indentationLevel > 0) // labels can not be generated in code blocks
                )
            {
               return true;
            }
         }

         return action.Calls <= 0
             || (action.Calls >= 2 && indentationLevel > 0)
             || indentationLevel >= GlobalVariables.NestingLevelLimit.Value;
      }

      /// <summary>
      /// If the referenced (accept) parser action can be generated at the actual place of code
      /// <para>then
      /// if forced by <paramref name="forceLabel"/> or if the (accept) parser action is referenced more than
      /// once a label is generated.
      /// If <paramref name="generateAccept"/> the accept instruction is generated and as just described a label.
      /// </para>
      /// Else a goto is generated and true is returned.
      /// </summary>
      /// <param name="forceLabel">Forces the generation of a label. The IndentationLevelLevel must be 0.</param>
      /// <param name="generateAccept">Selects whether the action will be generated with accept</param>
      /// <param name="parserAction">The action to which a goto or for which a label (if needed) shall be generated</param>
      /// <param name="beginOfBlockHasBeenGenerated">Gibt an, ob eine öffnende Klammer erzeugt wurde</param>
      /// 
      /// <returns>true, if goto has been generated</returns>
      private static Boolean GenerateOptionalLabelOptionalAcceptOrGoto(
         Boolean forceLabel, // because goto has been generated on IndentationLevel==0
         Boolean generateAccept,
         ParserAction parserAction,
         ref Boolean beginOfBlockHasBeenGenerated)
      {
         Boolean InsideBlock = GlobalVariables.Codegen.IndentationLevel > 0;

         if (generateAccept)
         {
            // generate accept part of action
            if (GenerateLabelOrGotoOrNothing
                  (forceLabel,
                   commentIfNoLabel: !(generateAccept || parserAction is ErrorhandlingAction || parserAction is ErrorHaltAction),
                   P5CodegenCS.GotoLabel(parserAction, accept: true),
                   parserAction.AcceptCalls,
                   InsideBlock))
               return true; // generated "goto accept..."

            // generated label "accept:..." or nothing;
            // now generate begin of cascaded block if inside of a new block
            if (InsideBlock && !beginOfBlockHasBeenGenerated)
            {
               GlobalVariables.Codegen.GenerateBeginOfBlock();
               beginOfBlockHasBeenGenerated = true;
            }

            // generate accept instruction
            GlobalVariables.Codegen.IndentExactly();
            GlobalVariables.Codegen.GenerateAcceptInstruction();
            parserAction.AcceptCalls = 0; // mark that the accept part of the action has been generated
            forceLabel = false; // forceLabel has already been evaluated
         }

         //generate action part of action
         if (GenerateLabelOrGotoOrNothing
               (forceLabel,
                commentIfNoLabel:
                !(parserAction is ErrorhandlingAction
                  || parserAction is ErrorHaltAction
                  || parserAction is HaltAction),
                P5CodegenCS.GotoLabel(parserAction, accept: false),
                parserAction.Calls,
                insideBlock: GlobalVariables.Codegen.IndentationLevel > 0))
            return true; // generated goto

         parserAction.Calls = 0;  // mark that the begin of the action part of the parser code has been generated
                                  // the parser code will be generated by the calling method immediately
         return false; // generated begin of the action part
      } // GenerateOptionalLabelOptionalAcceptOrGoto

      private static Boolean GenerateLabelOrGotoOrNothing(
         Boolean forceLabel, // because goto has been generated on IndentationLevel==0
         Boolean commentIfNoLabel,
         String label, // codegen.GenerateLabel(parserAction, generateAccept)
         Int32 calls, // = generateAccept ? parserAction.AcceptCalls : parserAction.Calls;
         Boolean insideBlock // IndentationLevel > 0
         )
      {
         Debug.Assert(!(forceLabel && insideBlock));

         Boolean GenerateGoto =
            calls <= 0 // code has been already generated or must not be generated
            || (calls > 1 && insideBlock)  // code with more than 1 reference needs label but label not allowed in block
            || GlobalVariables.Codegen.IndentationLevel >= GlobalVariables.NestingLevelLimit.Value; // code would be indented to much

         Boolean GenerateLabel =
            !GenerateGoto &&
            (forceLabel || calls > 1);

         if (GenerateGoto)
         {
            GlobalVariables.Codegen.GenerateGoto(label);
            return true; // goto has been generated
         }

         if (GenerateLabel)
         {
            GlobalVariables.Codegen.GenerateLabel(label);
         }
         else if (commentIfNoLabel)
            GlobalVariables.Codegen.IndentExactly().Append("// ").Append(label).AppendLine(":");

         return false;

      } // GenerateLabelOrGotoOrNothing (...)

      //public struct ActionAndCounter {
      //   public Int32 Counter;
      //   public Int32 MaxCondition, MinCondition;
      //   public ParserAction Action;

      //   public ActionAndCounter(Int32 counter, ParserAction action, Int32 minMaxCondition)
      //   {
      //      this.Counter = counter;
      //      this.Action = action;
      //      this.MinCondition = minMaxCondition;
      //      this.MaxCondition = minMaxCondition;
      //   }
      //}

      ///// <summary>
      ///// In der BranchToGenerate.ListOfCases kann als Folge der Optimierungen die gleiche Aktion mit verschiedenen Kennungen vorkommen.
      ///// In der ActionCounterList kommt jede Aktion daraus genau einmal vor. Der Zähler gibt an, wie oft sie in der ListOfCases vorkommt.
      ///// </summary>
      //public class ActionCounterList : List<ActionAndCounter> {
      //   private ActionCounterList(Int32 capacity) : base(capacity) { }

      //   private ActionCounterList()
      //   {
      //   }

      //   /// <summary>
      //   /// Constructs an ActionCounterList with the same length as the ListOfCases of the BranchToGenerate,
      //   /// adds all different branchcases counting duplicates, finally trims the list
      //   /// </summary>
      //   /// <param name="BranchToGenerate"></param>
      //   public ActionCounterList(BranchAction BranchToGenerate) : this(BranchToGenerate.ListOfCases.Count)
      //   {
      //      foreach (BranchcaseStruct branchcase in BranchToGenerate.ListOfCases)
      //      {
      //         // Die Aktion in der Liste suchen:
      //         Int32 FoundIndex = FindIndex(x => x.Action == branchcase.BranchcaseAction);

      //         if (FoundIndex == -1)
      //         { // not found
      //            Add(
      //               new ActionAndCounter(counter: 1, action: branchcase.BranchcaseAction,
      //               minMaxCondition: branchcase.BranchcaseCondition)
      //               );
      //         }
      //         else
      //         { // found:  increment counter and update MaxCondition
      //            ActionAndCounter actionAndCounter = this[FoundIndex];
      //            actionAndCounter.Counter++;
      //            if (actionAndCounter.MinCondition > branchcase.BranchcaseCondition)
      //               actionAndCounter.MinCondition = branchcase.BranchcaseCondition;
      //            if (actionAndCounter.MaxCondition < branchcase.BranchcaseCondition)
      //               actionAndCounter.MaxCondition = branchcase.BranchcaseCondition;
      //            this[FoundIndex] = actionAndCounter;
      //         }
      //      }
      //      TrimExcess();
      //   }
      //}

      //private ParserAction GenerateCondionalActionsOfBranch(BranchAction BranchToGenerate, out Boolean Accept)
      //{
      //   // Create a CounterList which is ready to use preset with one entry and counter for each different action in BranchtoGenerate  
      //   var CounterList = new ActionCounterList(BranchToGenerate);

      //   // if there is only one action: return it to be generated without condition
      //   if (CounterList.Count == 1)
      //   {
      //      Accept = false;
      //      return CounterList[0].Action;
      //   }

      //   // Select a default action
      //   // There are different criteria to select the default action:
      //   //   select the most frequent action to reduce the conditions;
      //   //   avoid goto actions to move them into the conditional part;
      //   //   avoid other simple actions to put them in the conditional part

      //   Int32 MinIndex = 0, PriorityIndex = 0, MaxIndex = 0;

      //   Int32 MinCondition = Int32.MaxValue;
      //   Int32 MaxCondition = Int32.MinValue;

      //   Int32 MinPriority = Int32.MinValue;
      //   Int32 Priority = Int32.MinValue;

      //   for (Int32 i = 0; i < CounterList.Count; i++)
      //   {
      //      var actionAndCounter = CounterList[i];
      //      // Select a default action to be generated as last:
      //      // select the most frequent action and if equal frequency
      //      // prefer actions with larger branch condition (to reduce the span of values to be tested in the generated switch)

      //      Int32 thisPriority = actionAndCounter.Counter * 1000 + actionAndCounter.MaxCondition;

      //      // but reduce the priority of actions which will be generated as goto
      //      if (GeneratesGoto(generateAccept: false, actionAndCounter.Action, codegen.IndentationLevel)
      //          // or of actions which will loop back 
      //          || (actionAndCounter.Action as ReduceAction)?.NextAction == BranchToGenerate
      //          // or of indirect or direct HaltActions
      //          || (actionAndCounter.Action as ReduceAction)?.NextAction is HaltAction
      //          || actionAndCounter.Action is HaltAction
      //          )
      //      {
      //         thisPriority -= (Int32.MaxValue >> 1);
      //      }

      //      if (actionAndCounter.MinCondition < MinCondition)
      //      {
      //         MinCondition = actionAndCounter.MinCondition;
      //         MinIndex = i;
      //         MinPriority = thisPriority;
      //      }
      //      if (actionAndCounter.MaxCondition > MaxCondition)
      //      {
      //         MaxCondition = actionAndCounter.MaxCondition;
      //         MaxIndex = i;
      //      }

      //      if (thisPriority > Priority)
      //      {
      //         PriorityIndex = i;
      //         Priority = thisPriority;
      //      }
      //   }

      //   // If the action with the MaxIndex didn't get priority 
      //   // then check if the action with the MinIndex is qualified as default action
      //   if (PriorityIndex != MaxIndex && MinPriority > 0)
      //      PriorityIndex = MinIndex;

      //   var defaultAction = CounterList[PriorityIndex].Action;

      //   // If there are only 2 different actions one of which has only one condition (Counter==1) to check for
      //   // then it is possible to generate an IF condition with one test for equality (or unequality)
      //   if (CounterList.Count == 2 && (CounterList[0].Counter == 1 || CounterList[1].Counter == 1))
      //   {
      //      GenerateBranchAsIFInstruction(BranchToGenerate, CounterList, defaultAction);
      //      Accept = false;
      //      return defaultAction;
      //   }

      //   return GenerateBranchAsSwitch(BranchToGenerate, out Accept, CounterList, defaultAction);
      //}

      //private ParserAction GenerateBranchAsSwitch(
      //    BranchAction branchToGenerate, out Boolean accept, ActionCounterList counterList, ParserAction defaultAction)
      //{
      //   // Generate a switch statement
      //   // Für jede Aktion ungleich Defaultaktion in der Zählliste alle gleichen Aktionen in der Falliste der Verzweigung suchen
      //   // und eine oder mehrere Case-Anweisungen erzeugen sowie einmal die Codefolge für die Aktion

      //   codegen.IndentExactly()
      //      .Append("switch (")
      //      .Append(GlobalVariables.StateStack.Value)
      //      .Append(".Peek())")
      //      .IndentExactly()
      //      .Append("{");

      //   foreach (ActionAndCounter ElementOFCounterList in counterList)
      //   {
      //      if (ElementOFCounterList.Action != defaultAction)
      //      {
      //         // Alle gleichen Aktionen suchen
      //         foreach (BranchcaseStruct f in branchToGenerate.ListOfCases)
      //         {
      //            if (f.BranchcaseAction == ElementOFCounterList.Action)
      //               codegen.IndentExactly()
      //                  .Append("case ")
      //                  .Append(f.BranchcaseCondition.ToString())
      //                  .Append(": ");

      //            // codegen.AppendInstruction("case ", f.BranchcaseCondition.ToString(), ": ");
      //         }

      //         // Die zugehörige Codefolge erzeugen
      //         codegen.IncrementIndentationLevel();
      //         GenerateCodeSequence(ElementOFCounterList.Action, false, false);
      //         codegen.DecrementIndentationLevel();
      //         // Die Codefolge endet immer mit einem GOTO - auch bei Halt !
      //      }
      //   }

      //   // Für die Defaultaktion analog

      //   // Alle gleichen Aktionen suchen und die case-Anweisungen als Kommentar erzeugen
      //   // Falls mehrere Fälle zusammengefast werden, ist die Zahl der Aufrufe der default-Aktion entsprechend zu verringern
      //   codegen.Indent().Append("/*");
      //   Int32 countOfDefaultCases = 0;
      //   foreach (BranchcaseStruct f in branchToGenerate.ListOfCases)
      //   {
      //      if (f.BranchcaseAction == defaultAction)
      //      {
      //         countOfDefaultCases++;
      //         codegen.AppendWithOptionalLinebreak("case ", f.BranchcaseCondition.ToString(), ": ");
      //      }
      //   }

      //   if (countOfDefaultCases > 1)
      //      defaultAction.Calls -= countOfDefaultCases - 1;
      //   // Die auskommentierte Default-Codefolge  und das Kommentarende erzeugen
      //   codegen.IndentAndAppendLine("default: break; */")
      //   .IndentExactly()
      //   .AppendLine("}");
      //   accept = false;
      //   return defaultAction;
      //}

      ///// <summary>
      ///// generate an if instruction so that not the default action will be executed conditionally 
      ///// and the default action will remain to be generated in the codesequence
      ///// </summary>
      ///// <param name="branchToGenerate"></param>
      ///// <param name="counterList"></param>
      ///// <param name="defaultAction"></param>
      ///// 
      //private void GenerateBranchAsIFInstruction(BranchAction branchToGenerate, ActionCounterList counterList, ParserAction defaultAction)
      //{
      //   // The simple condition case is the case whose BranchcaseCondition occurs only once in the branchToGenerate.ListOfCases
      //   // Its BranchcaseCondition (int value) will be used as condition in the generated if instruction.
      //   Int32 simpleConditionCaseIndex = 0, complexConditionCaseIndex = 1; // initial assignment

      //   if (counterList[simpleConditionCaseIndex].Counter != 1
      //      // if each of both action occurs only once use the default-Action as complexCase
      //      || (counterList[complexConditionCaseIndex].Counter == 1 && counterList[simpleConditionCaseIndex].Action == defaultAction))
      //   {
      //      // change the initial assignment
      //      simpleConditionCaseIndex = 1;
      //      complexConditionCaseIndex = 0;
      //   }

      //   ParserAction simpleConditionCase = counterList[simpleConditionCaseIndex].Action;
      //   ParserAction complexConditionCase = counterList[complexConditionCaseIndex].Action;
      //   Int32 complexCaseCounter = counterList[complexConditionCaseIndex].Counter;

      //   // simpleCaseCounter == 1   !

      //   // Find simpleCase in the ListOfCases - where it occurs only once - to get its condition
      //   Int32 simpleCaseCondition = branchToGenerate.ListOfCases.Find(x => x.BranchcaseAction == simpleConditionCase).BranchcaseCondition;

      //   if (complexConditionCase == defaultAction)
      //   {
      //      codegen.GenerateIfSPeek(false, simpleCaseCondition);
      //      // generate simpleCase
      //      codegen.IncrementIndentationLevel();
      //      GenerateCodeSequence(simpleConditionCase, false, false);
      //      codegen.DecrementIndentationLevel();
      //      // Adjust the number of calls because some actions are handled together 
      //      if (complexConditionCase.Calls > 0)
      //         complexConditionCase.Calls -= complexCaseCounter - 1;
      //   }
      //   else
      //   {  // simpleCase == defaultAction
      //      // generate the complement of the condition of simpleCase-condition 
      //      codegen.GenerateIfSPeek(true, simpleCaseCondition);
      //      // generate complexCase
      //      // Adjust the number of calls because some actions are handled together
      //      if (complexConditionCase.Calls > 0)
      //         complexConditionCase.Calls -= complexCaseCounter - 1;
      //      codegen.IncrementIndentationLevel();
      //      GenerateCodeSequence(complexConditionCase, false, false);
      //      codegen.DecrementIndentationLevel();
      //   }
      //}

      /// <summary>
      /// Compare a and b such that the sort will will result in a-b:
      /// <para>- if a is a <see cref="ConditionalAction>"/> and b is not</para>
      /// <para>- if a has lower <see cref="ConditionalAction.Complexity"/></para>
      /// <para>- if a has higher <see cref="ConditionalAction.SumOfWeights"/> (set to 0 for <see cref="ErrorhandlingAction"/>)</para>
      /// <para>- if a has <see cref="ParserAction.Calls"/>&lt;= 1 and b not</para> 
      /// <para> - if a has smaller <see cref="ParserAction.IdNumber"/></para>
      /// </summary>
      /// <param name="ActionA"></param>
      /// <param name="b"></param>
      /// <returns></returns>
      static internal Int32 CompareWeightandConditionComplexity(ParserAction? a, ParserAction? b)
      {
         // result < 0  sort order will be a then b
         // result == 0  a will not happen if a != b
         // result > 0  sort order will be b then a

         if (!(a is ConditionalAction ActionA))
            return (b == null) ? 0 : 1;
         if (!(b is ConditionalAction ActionB))
            return -1;

         Single PositionA = Position(ActionA);

         Single PositionB = Position(ActionB);

         if (PositionA != PositionB)
            return (Int32)(PositionA - PositionB);

         return (ActionA).IdNumber - ActionB.IdNumber;
      }

      private static Single Position(ConditionalAction action)
      {
         Single PositionA = action.Complexity * 100_000
            + (action is ErrorhandlingAction
              ? -0
              : -10 * action.SumOfWeights);

         // if NextAction is called only once ( ...calls==1) it can be generated inline and
         // perhaps the other actions NextAction might be generated at the end (lower indentation level)
         // if NextAction has been generated already (... calls<=0) it will generate a goto
         if (action is TerminalTransition)
            PositionA += ((action.NextAction.AcceptCalls <= 1) ? -5.0f : 0.0f);
         else
            PositionA += ((action.NextAction.Calls <= 1) ? -5.0f : 0.0f);
         return PositionA;
      }

      /// <summary>
      /// Compares ActionA.TerminalSymbols.IndexOfFirstTrueElement() with ActionB...
      /// </summary>
      /// <param name="a">Action A</param>
      /// <param name="b">Action B</param>
      /// <returns></returns>
      internal static Int32 CompareIndexOfFirstTrueElement(ParserAction a, ParserAction b)
      {
         if (!(a is ConditionalAction ActionA))
            return (b == null) ? 0 : 1;
         if (!(b is ConditionalAction ActionB))
            return -1;

         Int32 First1 = ActionA.TerminalSymbols.IndexOfFirstTrueElement();
         Int32 First2 = ActionB.TerminalSymbols.IndexOfFirstTrueElement();

         if (First1 != First2)
            return First1 - First2;

         return ActionA.IdNumber - ActionB.IdNumber;
      }

      /// <summary>
      /// Generates nothing if .Calls (resp. .AccepCalls) &lt;=0.
      /// Generates goto xxx, if the code has been generated or can not be generated at the actual nesting level.
      /// Generates accept if the action to be generated is a <see cref="TerminalTransition"/>.
      /// Sets .Calls (resp. .AcceptCalls) to 0.
      /// </summary>
      /// <param name="actionToGenerate"></param>
      /// <param name="labelMustBeGenerated"></param>
      /// 
      static internal void GenerateCodeSequence(P5CodegenCS codegen, ParserActionWithNextAction actionToGenerate, Boolean labelMustBeGenerated)
      {
         GenerateCodeSequence(codegen,
             actionToGenerate:
                actionToGenerate is ErrorhandlingAction || actionToGenerate is PrioritySelectAction
                   ? actionToGenerate // ErrorhandlingAction | PrioritySelectAction
                   : actionToGenerate.NextAction, // LookaheadAction | TerminalTransition: condition has been generated already
            accept: actionToGenerate is TerminalTransition,
            labelMustBeGenerated: labelMustBeGenerated);
      }

      /// <summary>
      /// Generates nothing if .Calls (resp. .AccepCalls) &lt;=0.
      /// Generates goto xxx, if the code has been generated or can not be generated at the actual nesting leve.
      /// Sets .Calls (resp. .AcceptCalls) to 0.
      /// </summary>
      /// <param name="actionToGenerate"></param>
      /// <param name="accept"></param>
      /// <param name="labelMustBeGenerated"></param>
      /// 
      [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "e")]
      static internal void GenerateCodeSequence(P5CodegenCS codegen, ParserAction actionToGenerate, Boolean accept, Boolean labelMustBeGenerated)
      {
         ParserAction? ActionToGenerate = actionToGenerate;
         Boolean Accept = accept;
         Boolean GotoHasBeenGenerated = labelMustBeGenerated;

         Boolean BeginOfBlockHasBeenGenerated = false;

         while (ActionToGenerate != null)
         {
            GotoHasBeenGenerated =
                GenerateOptionalLabelOptionalAcceptOrGoto(
                   forceLabel: GotoHasBeenGenerated,
                   generateAccept: Accept,
                   parserAction: ActionToGenerate,
                   beginOfBlockHasBeenGenerated: ref BeginOfBlockHasBeenGenerated);

            if (GotoHasBeenGenerated)
               break;

            // if need generate begin of block
            if (!BeginOfBlockHasBeenGenerated && codegen.IndentationLevel > 0)
            {
               codegen.GenerateBeginOfBlock();
               BeginOfBlockHasBeenGenerated = true;
            }

            ActionToGenerate = ActionToGenerate.Generate(codegen, out Accept);

         }

         if (BeginOfBlockHasBeenGenerated)
         {
            codegen.IndentExactly();
            codegen.GenerateEndOfBlock("");
         }

         // No action to generate => if topmost level the next code can only be reached by a goto.
         // Generate an empty line preceding the label that will be generated.
         if (codegen.IndentationLevel == 0)
            codegen.AppendLine(' ');

      } // private ... CodefolgeErzeugen(...)

      /// <summary>
      /// Generates code for all not yet generated actions with Calls &gt; <paramref name="MinimumOfCalls"/>"/>
      /// </summary>
      /// <param name="MinimumOfCalls">Mindestzahl von Aufrufen</param>
      private void GenerateCodeWithLabels(Int32 MinimumOfCalls)
      {
         /* Each action a with a.xxxCalls == 1 has a good chance to be generated as part of another action
          * (if not prohibited by the nesting level limit). The generation of these actions is delayed.
          * 
          * Each action a with a.xxxCalls > 1 needs a label and can not be generated
          * in nested instructions (but following another action as next action).
          * 
          * The following code is a simple heuristic (!) to get a sequence where 
          * actions are generated earlier than actions they contain.
          * 
          * Another perhaps better to optimize solution would be to sort the actions in advance.
          */

         /* Generate ReduceActions early if
          * * their next action has not yet been generated
          * * their next action has more than one call
          * Typically the next action of ReduceActions are States.
          */

         foreach (ReduceAction r in GlobalVariables.ListOfAllReductions)
         {
            if (r.NextAction.Calls > 1)
            {
               if (r.AcceptCalls >= MinimumOfCalls)
                  GenerateCodeSequence(Codegen, r, accept: true, labelMustBeGenerated: true);
               if (r.Calls >= MinimumOfCalls)
                  GenerateCodeSequence(Codegen, r, accept: false, labelMustBeGenerated: true);
            }
         }

         /* Generate ParserStates early because they often include other actions or have a next action 
          */
         foreach (ParserState state in GlobalVariables.ListOfAllStates)
         {
            if (state.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, state, accept: true, labelMustBeGenerated: true);
            if (state.Calls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, state, accept: false, labelMustBeGenerated: true);
         }

         /* Typically PrioritySelectActions will have PriorityBranchActions as NextAction
          * and PriorityBranchActions will have ReduceActions as NextActions
          */
         foreach (PrioritySelectAction ps in GlobalVariables.ListOfAllPrioritySelectActions)
         {
            if (ps.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, ps, accept: true, labelMustBeGenerated: true);
            if (ps.Calls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, ps, accept: false, labelMustBeGenerated: true);
         }

         foreach (PriorityBranchAction pb in GlobalVariables.ListOfAllPriorityBranchActions)
         {
            if (pb.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, pb, accept: true, labelMustBeGenerated: true);
            if (pb.Calls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, pb, accept: false, labelMustBeGenerated: true);
         }


         /* Generate the other ReduceActions 
          */
         foreach (ReduceAction r in GlobalVariables.ListOfAllReductions)
         {
            if (r.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, r, accept: true, labelMustBeGenerated: true);
            if (r.Calls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, r, accept: false, labelMustBeGenerated: true);
         }

         /* Typically branches are next actions of ReduceActions. So generate them after those 
          */
         foreach (BranchAction b in GlobalVariables.ListOfAllBranchActions)
         {
            if (b.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, b, accept: true, labelMustBeGenerated: true);
            if (b.Calls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, b, accept: false, labelMustBeGenerated: true);
         }

         foreach (ErrorhandlingAction e in GlobalVariables.ListOfAllErrorhandlingActions)
         {
            if (e.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, e, accept: true, labelMustBeGenerated: true);
            if (e.Calls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, e, accept: false, labelMustBeGenerated: true);
         }

         foreach (HaltAction h in GlobalVariables.ListOfAllHaltActions)
         {
            if (h.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, h, accept: true, labelMustBeGenerated: true);
            if (h.Calls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, h, accept: false, labelMustBeGenerated: true);
         }

         // PushStateActions are next actions of conditional actions.
         foreach (PushStateAction p in GlobalVariables.ListOfAllPushStateActions)
         {
            // Because AcceptCalls<=1, Calls==1 PushStateActions are generated without labels
            // and the following should only be executed
            // if this assumption is changed by some  modifications of grammlator 
            Debug.Assert(p.AcceptCalls <= 0 && p.Calls <= 0);
            if (p.AcceptCalls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, p, accept: true, labelMustBeGenerated: true);
            if (p.Calls >= MinimumOfCalls)
               GenerateCodeSequence(Codegen, p, accept: false, labelMustBeGenerated: true);
         }
      } // void FehlendenCodeErzeugen
   } // class Phase5
} // namespace ...




